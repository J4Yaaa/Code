C++ 98,建议不要使用
第一种:
交出资源的管理权,在拷贝构造或者是赋值运算符中
AutoPtr<int> a(b);
a.拷贝构造(b); 用b去拷贝构造a,那就将b的资源管理权交出,b就是NULL;
a = b; 
a.operaort(b); 将b赋值给a,那也将b的资源管理权交出,b就是NULL;

第二种:
在定义一个成员变量,表示当前这个对象是不是管理着这块资源
只有管理着才有资格释放这块资源

拷贝构造的时候: 将a的_owner置为b的_owner值,将b的_owner置为假.
赋值同理


这两种方式都不好
第一种会限制原指针的访问权
第二种缺陷是,如下:
void FunTest()
{
    AutoPtr<int> ap1(new int);
    if(true)
    {
        AutoPtr<int> ap2(ap1);
    }
    *ap1 = 10;
}
ap2在if语句中被拷贝构造出来,那么ap1实际上已经将管理权交给了ap2
当ap2在大括号中被释放掉,外面的ap1根本感知不到
而我们也不能依靠_onwer来判断当前ap1是否有资源
如果在对他冒然解引用,就可能导致程序崩溃.
所以在这一点上,还是第一种方法比较好
